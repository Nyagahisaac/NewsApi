import { ChangeDetectionStrategy, Component, Injectable, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';
import { timer as timer$1 } from 'rxjs/observable/timer';
import { distinctUntilChanged, filter, map, skip, switchMap, takeWhile, tap } from 'rxjs/operators';
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Keep value within the range
 */
var clamp = function (n, min, max) {
    if (n < min) {
        return min;
    }
    if (n > max) {
        return max;
    }
    return n;
};
var NgProgress = (function () {
    function NgProgress() {
        var _this = this;
        /**
         * Initial state
         */
        this.initState = {
            active: false,
            value: 0
        };
        /**
         * Progress state
         */
        this.state$ = new BehaviorSubject$1(this.initState);
        /**
         * Trickling stream
         */
        this.trickling$ = new Subject$1();
        this.progress = 0;
        this.maximum = 1;
        this.minimum = 0.08;
        this.speed = 200;
        this.trickleSpeed = 300;
        this.trickling$.pipe(switchMap(function () { return timer$1(0, _this.trickleSpeed).pipe(takeWhile(function () { return _this.isStarted; }), tap(function () { return _this.inc(); })); })).subscribe();
    }
    Object.defineProperty(NgProgress.prototype, "isStarted", {
        /**
         * Is progress started
         * @return {?}
         */
        get: function () {
            return this.progress > 0 && this.progress < this.maximum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgress.prototype, "started", {
        /**
         * Progress start event
         * @return {?}
         */
        get: function () {
            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return active; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgress.prototype, "ended", {
        /**
         * Progress ended event
         * @return {?}
         */
        get: function () {
            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return !active; }), skip(1));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start
     * @return {?}
     */
    NgProgress.prototype.start = function () {
        if (!this.isStarted) {
            this.set(this.minimum);
        }
        this.trickling$.next();
    };
    /**
     * Done
     * @return {?}
     */
    NgProgress.prototype.done = function () {
        /** if started, complete the progress */
        if (this.isStarted) {
            this.set(.3 + .5 * Math.random());
            this.set(this.maximum);
        }
    };
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    NgProgress.prototype.inc = function (amount) {
        var /** @type {?} */ n = this.progress;
        /** if it hasn't start, start */
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                if (n >= 0 && n < 0.2) {
                    amount = 0.1;
                }
                else if (n >= 0.2 && n < 0.5) {
                    amount = 0.04;
                }
                else if (n >= 0.5 && n < 0.8) {
                    amount = 0.02;
                }
                else if (n >= 0.8 && n < 0.99) {
                    amount = 0.005;
                }
                else {
                    amount = 0;
                }
            }
            n = clamp(n + amount, 0, 0.994);
            this.set(n);
        }
    };
    /**
     * Set the progress
     * @param {?} n - Progress value
     * @return {?}
     */
    NgProgress.prototype.set = function (n) {
        var _this = this;
        this.progress = clamp(n, this.minimum, this.maximum);
        this.updateState(this.progress, true);
        /** if progress completed */
        if (n === this.maximum) {
            var /** @type {?} */ hide_1 = function () {
                /**
                         *  reset the progress
                         *  Keep it { 0, false } to fadeOut progress-bar after complete
                         */
                if (_this.progress >= _this.maximum) {
                    _this.progress = 0;
                    _this.updateState(_this.progress, false);
                }
            };
            var /** @type {?} */ complete = function () {
                /**
                         * complete the progress
                         * { 1, false } to complete progress-bar before hiding
                         */
                if (_this.progress >= _this.maximum) {
                    _this.updateState(_this.progress, false);
                    setTimeout(hide_1, _this.speed);
                }
            };
            setTimeout(complete, this.speed);
        }
    };
    /**
     * Update progress state
     * @param {?} progress - Progress value
     * @param {?} isActive - Progress active
     * @return {?}
     */
    NgProgress.prototype.updateState = function (progress, isActive) {
        this.state$.next({
            active: isActive,
            value: progress
        });
    };
    return NgProgress;
}());
NgProgress.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgProgress.ctorParameters = function () { return []; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */
var NgProgressBarComponent = (function () {
    /**
     * @param {?} progress
     */
    function NgProgressBarComponent(progress) {
        this.progress = progress;
    }
    /**
     * @return {?}
     */
    NgProgressBarComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.state$ = this.progress.state$.pipe(map(function (state) { return ({
            containerClasses: _this.containerClasses(state),
            progressStyles: _this.progressBarStyles(state),
            spinnerClasses: _this.spinnerClasses(),
            spinnerStyles: _this.spinnerStyles(),
            meteorStyles: _this.meteor ? _this.meteorStyles() : null
        }); }));
    };
    /**
     * @param {?} state
     * @return {?}
     */
    NgProgressBarComponent.prototype.containerClasses = function (state) {
        return {
            active: state.active,
            thick: this.thick
        };
    };
    /**
     * @param {?} state
     * @return {?}
     */
    NgProgressBarComponent.prototype.progressBarStyles = function (state) {
        var /** @type {?} */ n = (!state.value) ? directionSwitcher[this.direction].bar : this.toPercentage(state.value);
        var /** @type {?} */ translate3d = "translate3d(" + n + "%,0,0)";
        return {
            transition: "all " + this.speed + "ms " + this.ease,
            background: this.color,
            msTransform: translate3d,
            webkitTransform: translate3d,
            transform: translate3d
        };
    };
    /**
     * Styles for progressbar tail
     * @return {?}
     */
    NgProgressBarComponent.prototype.meteorStyles = function () {
        return {
            boxShadow: "0 0 10px " + this.color + ", 0 0 5px " + this.color,
            left: directionSwitcher[this.direction].meteorLeft,
            transform: directionSwitcher[this.direction].meteorRotate(this.thick),
        };
    };
    /**
     * Convert number to percent
     * @param {?} n - State value
     * @return {?}
     */
    NgProgressBarComponent.prototype.toPercentage = function (n) {
        return directionSwitcher[this.direction].toPercentage(n) * 100;
    };
    /**
     * Spinner direction
     * @return {?}
     */
    NgProgressBarComponent.prototype.spinnerClasses = function () {
        return directionSwitcher[this.direction].spinnerClass + ' spinner-' + this.spinnerPosition;
    };
    /**
     * Spinner styles
     * @return {?}
     */
    NgProgressBarComponent.prototype.spinnerStyles = function () {
        return {
            borderTopColor: this.color,
            borderLeftColor: this.color
        };
    };
    return NgProgressBarComponent;
}());
NgProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress-bar',
                template: "<div class=\"ng-progress\" *ngIf=\"state$ | async; let state\" [ngClass]=\"state.containerClasses\">\n  <div class=\"bar\" [ngStyle]=\"state.progressStyles\">\n    <div *ngIf=\"meteor\" class=\"meteor\" [ngStyle]=\"state.meteorStyles\"></div>\n  </div>\n  <div *ngIf=\"spinner\" class=\"spinner {{state.spinnerClasses}}\">\n    <div class=\"spinner-icon\" [ngStyle]=\"state.spinnerStyles\"></div>\n  </div> \n</div>\n",
                styles: [".ng-progress {\n  z-index: 999999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  position: fixed;\n  zoom: 1;\n  filter: alpha(opacity=0);\n  opacity: 0;\n  -webkit-transition: opacity 200ms linear;\n  transition: opacity 200ms linear; }\n\n.active {\n  filter: alpha(opacity=100);\n  opacity: 1;\n  -webkit-transition: none;\n  transition: none; }\n\n.bar {\n  position: absolute;\n  width: 100%;\n  height: 2px; }\n\n.thick .bar {\n  height: 3px; }\n\n.meteor {\n  display: block;\n  position: absolute;\n  right: 0;\n  top: -3px;\n  width: 100px;\n  height: 100%;\n  opacity: 1.0; }\n\n.thick .meteor {\n  top: -4px; }\n\n.thick .spinner-icon {\n  width: 24px;\n  height: 24px;\n  border: solid 3px transparent; }\n\n.spinner {\n  display: block;\n  position: fixed;\n  z-index: 1031;\n  top: 15px;\n  right: 15px; }\n  .spinner.spinner-left {\n    left: 15px;\n    right: unset; }\n\n.spinner-icon {\n  width: 18px;\n  height: 18px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  border: solid 2px transparent;\n  border-radius: 50%;\n  -webkit-animation: nprogress-spinner 400ms linear infinite;\n          animation: nprogress-spinner 400ms linear infinite; }\n\n.anti-clockwise .spinner-icon {\n  animation-direction: reverse; }\n\n@-webkit-keyframes nprogress-spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes nprogress-spinner {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n"],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NgProgressBarComponent.ctorParameters = function () { return [
    { type: NgProgress, },
]; };
NgProgressBarComponent.propDecorators = {
    "ease": [{ type: Input },],
    "speed": [{ type: Input },],
    "meteor": [{ type: Input },],
    "spinner": [{ type: Input },],
    "spinnerPosition": [{ type: Input },],
    "direction": [{ type: Input },],
    "thick": [{ type: Input },],
    "color": [{ type: Input },],
};
var ɵ0 = function (n) { return -1 + n; };
var ɵ1 = function (thick) { return "rotate(" + (thick ? 4 : 3) + "deg)"; };
var ɵ2 = function (n) { return -n; };
var ɵ3 = function (thick) { return "rotate(" + (thick ? 4 : 3) + "deg)"; };
var ɵ4 = function (n) { return 1 - n; };
var ɵ5 = function (thick) { return "rotate(" + (thick ? -4 : -3) + "deg)"; };
var ɵ6 = function (n) { return n; };
var ɵ7 = function (thick) { return "rotate(" + (thick ? -4 : -3) + "deg)"; };
var directionSwitcher = {
    leftToRightIncreased: {
        bar: -100,
        toPercentage: ɵ0,
        spinnerClass: 'clockwise',
        meteorRotate: ɵ1,
        meteorLeft: 'unset'
    },
    leftToRightReduced: {
        bar: 0,
        toPercentage: ɵ2,
        spinnerClass: 'anti-clockwise',
        meteorRotate: ɵ3,
        meteorLeft: 'unset'
    },
    rightToLeftIncreased: {
        bar: 100,
        toPercentage: ɵ4,
        spinnerClass: 'anti-clockwise',
        meteorRotate: ɵ5,
        meteorLeft: 0
    },
    rightToLeftReduced: {
        bar: 0,
        toPercentage: ɵ6,
        spinnerClass: 'clockwise',
        meteorRotate: ɵ7,
        meteorLeft: 0
    }
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgProgressComponent = (function () {
    /**
     * @param {?} progress
     */
    function NgProgressComponent(progress) {
        this.progress = progress;
        /**
         * Progress options
         */
        this.ease = 'linear';
        this.meteor = true;
        this.spinner = true;
        this.spinnerPosition = 'right';
        this.direction = 'leftToRightIncreased';
        this.color = '#1B95E0';
        this.thick = false;
        this.maximum = 1;
        this.minimum = 0.08;
        this.speed = 200;
        this.trickleSpeed = 300;
    }
    Object.defineProperty(NgProgressComponent.prototype, "toggleProgressbar", {
        /**
         * Start/Stop Progressbar
         * @param {?} toggle
         * @return {?}
         */
        set: function (toggle) {
            toggle ? this.progress.start() : this.progress.done();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnChanges = function (changes) {
        var /** @type {?} */ minChng = changes["minimum"];
        var /** @type {?} */ maxChng = changes["maximum"];
        var /** @type {?} */ spdChng = changes["speed"];
        var /** @type {?} */ tklSpdChng = changes["trickleSpeed"];
        if (minChng) {
            if (typeof minChng.currentValue !== 'undefined' && minChng.currentValue !== minChng.previousValue) {
                if (minChng.currentValue < 0 || minChng.currentValue > 1) {
                    throw new Error('Input [minimum] must be between 0 and 1');
                }
                else {
                    this.progress.minimum = minChng.currentValue;
                }
            }
        }
        if (maxChng) {
            if (typeof maxChng.currentValue !== 'undefined' && maxChng.currentValue !== maxChng.previousValue) {
                if (maxChng.currentValue < 0 || maxChng.currentValue > 1) {
                    throw new Error('Input [maximum] must be between 0 and 1');
                }
                else {
                    this.progress.maximum = maxChng.currentValue;
                }
            }
        }
        if (spdChng) {
            if (typeof spdChng.currentValue !== 'undefined' && spdChng.currentValue !== spdChng.previousValue) {
                this.progress.speed = spdChng.currentValue;
            }
        }
        if (tklSpdChng) {
            if (typeof tklSpdChng.currentValue !== 'undefined' && tklSpdChng.currentValue !== tklSpdChng.previousValue) {
                this.progress.trickleSpeed = tklSpdChng.currentValue;
            }
        }
    };
    return NgProgressComponent;
}());
NgProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress',
                template: "<ng-progress-bar\n    [speed]=\"speed\"\n    [ease]=\"ease\"\n    [meteor]=\"meteor\"\n    [spinner]=\"spinner\"\n    [spinnerPosition]=\"spinnerPosition\"\n    [direction]=\"direction\"\n    [color]=\"color\"\n    [thick]=\"thick\"\n></ng-progress-bar>",
                styles: [":host {\n  z-index: 999999;\n  pointer-events: none;\n  position: relative; }\n"],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NgProgressComponent.ctorParameters = function () { return [
    { type: NgProgress, },
]; };
NgProgressComponent.propDecorators = {
    "ease": [{ type: Input },],
    "meteor": [{ type: Input },],
    "spinner": [{ type: Input },],
    "spinnerPosition": [{ type: Input },],
    "direction": [{ type: Input },],
    "color": [{ type: Input },],
    "thick": [{ type: Input },],
    "maximum": [{ type: Input },],
    "minimum": [{ type: Input },],
    "speed": [{ type: Input },],
    "trickleSpeed": [{ type: Input },],
    "toggleProgressbar": [{ type: Input, args: ['toggle',] },],
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgProgressModule = (function () {
    function NgProgressModule() {
    }
    /**
     * @return {?}
     */
    NgProgressModule.forRoot = function () {
        return {
            ngModule: NgProgressModule,
            providers: [NgProgress]
        };
    };
    return NgProgressModule;
}());
NgProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NgProgressComponent,
                    NgProgressBarComponent
                ],
                exports: [NgProgressComponent],
                imports: [CommonModule]
            },] },
];
/** @nocollapse */
NgProgressModule.ctorParameters = function () { return []; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */
export { NgProgressModule, NgProgress, NgProgressBarComponent as ɵb, NgProgressComponent as ɵa };
//# sourceMappingURL=ngx-progressbar-core.js.map
