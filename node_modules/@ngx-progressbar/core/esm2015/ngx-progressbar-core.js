import { ChangeDetectionStrategy, Component, Injectable, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';
import { timer as timer$1 } from 'rxjs/observable/timer';
import { distinctUntilChanged, filter, map, skip, switchMap, takeWhile, tap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Keep value within the range
 */
const clamp = (n, min, max) => {
    if (n < min) {
        return min;
    }
    if (n > max) {
        return max;
    }
    return n;
};
class NgProgress {
    constructor() {
        /**
         * Initial state
         */
        this.initState = {
            active: false,
            value: 0
        };
        /**
         * Progress state
         */
        this.state$ = new BehaviorSubject$1(this.initState);
        /**
         * Trickling stream
         */
        this.trickling$ = new Subject$1();
        this.progress = 0;
        this.maximum = 1;
        this.minimum = 0.08;
        this.speed = 200;
        this.trickleSpeed = 300;
        this.trickling$.pipe(switchMap(() => timer$1(0, this.trickleSpeed).pipe(takeWhile(() => this.isStarted), tap(() => this.inc())))).subscribe();
    }
    /**
     * Is progress started
     * @return {?}
     */
    get isStarted() {
        return this.progress > 0 && this.progress < this.maximum;
    }
    /**
     * Progress start event
     * @return {?}
     */
    get started() {
        return this.state$.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => active));
    }
    /**
     * Progress ended event
     * @return {?}
     */
    get ended() {
        return this.state$.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => !active), skip(1));
    }
    /**
     * Start
     * @return {?}
     */
    start() {
        if (!this.isStarted) {
            this.set(this.minimum);
        }
        this.trickling$.next();
    }
    /**
     * Done
     * @return {?}
     */
    done() {
        /** if started, complete the progress */
        if (this.isStarted) {
            this.set(.3 + .5 * Math.random());
            this.set(this.maximum);
        }
    }
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    inc(amount) {
        let /** @type {?} */ n = this.progress;
        /** if it hasn't start, start */
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                if (n >= 0 && n < 0.2) {
                    amount = 0.1;
                }
                else if (n >= 0.2 && n < 0.5) {
                    amount = 0.04;
                }
                else if (n >= 0.5 && n < 0.8) {
                    amount = 0.02;
                }
                else if (n >= 0.8 && n < 0.99) {
                    amount = 0.005;
                }
                else {
                    amount = 0;
                }
            }
            n = clamp(n + amount, 0, 0.994);
            this.set(n);
        }
    }
    /**
     * Set the progress
     * @param {?} n - Progress value
     * @return {?}
     */
    set(n) {
        this.progress = clamp(n, this.minimum, this.maximum);
        this.updateState(this.progress, true);
        /** if progress completed */
        if (n === this.maximum) {
            const /** @type {?} */ hide = () => {
                /**
                         *  reset the progress
                         *  Keep it { 0, false } to fadeOut progress-bar after complete
                         */
                if (this.progress >= this.maximum) {
                    this.progress = 0;
                    this.updateState(this.progress, false);
                }
            };
            const /** @type {?} */ complete = () => {
                /**
                         * complete the progress
                         * { 1, false } to complete progress-bar before hiding
                         */
                if (this.progress >= this.maximum) {
                    this.updateState(this.progress, false);
                    setTimeout(hide, this.speed);
                }
            };
            setTimeout(complete, this.speed);
        }
    }
    /**
     * Update progress state
     * @param {?} progress - Progress value
     * @param {?} isActive - Progress active
     * @return {?}
     */
    updateState(progress, isActive) {
        this.state$.next({
            active: isActive,
            value: progress
        });
    }
}
NgProgress.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgProgress.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NgProgressBarComponent {
    /**
     * @param {?} progress
     */
    constructor(progress) {
        this.progress = progress;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.state$ = this.progress.state$.pipe(map((state) => ({
            containerClasses: this.containerClasses(state),
            progressStyles: this.progressBarStyles(state),
            spinnerClasses: this.spinnerClasses(),
            spinnerStyles: this.spinnerStyles(),
            meteorStyles: this.meteor ? this.meteorStyles() : null
        })));
    }
    /**
     * @param {?} state
     * @return {?}
     */
    containerClasses(state) {
        return {
            active: state.active,
            thick: this.thick
        };
    }
    /**
     * @param {?} state
     * @return {?}
     */
    progressBarStyles(state) {
        const /** @type {?} */ n = (!state.value) ? directionSwitcher[this.direction].bar : this.toPercentage(state.value);
        const /** @type {?} */ translate3d = `translate3d(${n}%,0,0)`;
        return {
            transition: `all ${this.speed}ms ${this.ease}`,
            background: this.color,
            msTransform: translate3d,
            webkitTransform: translate3d,
            transform: translate3d
        };
    }
    /**
     * Styles for progressbar tail
     * @return {?}
     */
    meteorStyles() {
        return {
            boxShadow: `0 0 10px ${this.color}, 0 0 5px ${this.color}`,
            left: directionSwitcher[this.direction].meteorLeft,
            transform: directionSwitcher[this.direction].meteorRotate(this.thick),
        };
    }
    /**
     * Convert number to percent
     * @param {?} n - State value
     * @return {?}
     */
    toPercentage(n) {
        return directionSwitcher[this.direction].toPercentage(n) * 100;
    }
    /**
     * Spinner direction
     * @return {?}
     */
    spinnerClasses() {
        return directionSwitcher[this.direction].spinnerClass + ' spinner-' + this.spinnerPosition;
    }
    /**
     * Spinner styles
     * @return {?}
     */
    spinnerStyles() {
        return {
            borderTopColor: this.color,
            borderLeftColor: this.color
        };
    }
}
NgProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress-bar',
                template: `<div class="ng-progress" *ngIf="state$ | async; let state" [ngClass]="state.containerClasses">
  <div class="bar" [ngStyle]="state.progressStyles">
    <div *ngIf="meteor" class="meteor" [ngStyle]="state.meteorStyles"></div>
  </div>
  <div *ngIf="spinner" class="spinner {{state.spinnerClasses}}">
    <div class="spinner-icon" [ngStyle]="state.spinnerStyles"></div>
  </div> 
</div>
`,
                styles: [`.ng-progress {
  z-index: 999999;
  top: 0;
  left: 0;
  width: 100%;
  position: fixed;
  zoom: 1;
  filter: alpha(opacity=0);
  opacity: 0;
  -webkit-transition: opacity 200ms linear;
  transition: opacity 200ms linear; }

.active {
  filter: alpha(opacity=100);
  opacity: 1;
  -webkit-transition: none;
  transition: none; }

.bar {
  position: absolute;
  width: 100%;
  height: 2px; }

.thick .bar {
  height: 3px; }

.meteor {
  display: block;
  position: absolute;
  right: 0;
  top: -3px;
  width: 100px;
  height: 100%;
  opacity: 1.0; }

.thick .meteor {
  top: -4px; }

.thick .spinner-icon {
  width: 24px;
  height: 24px;
  border: solid 3px transparent; }

.spinner {
  display: block;
  position: fixed;
  z-index: 1031;
  top: 15px;
  right: 15px; }
  .spinner.spinner-left {
    left: 15px;
    right: unset; }

.spinner-icon {
  width: 18px;
  height: 18px;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  border: solid 2px transparent;
  border-radius: 50%;
  -webkit-animation: nprogress-spinner 400ms linear infinite;
          animation: nprogress-spinner 400ms linear infinite; }

.anti-clockwise .spinner-icon {
  animation-direction: reverse; }

@-webkit-keyframes nprogress-spinner {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg); }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg); } }

@keyframes nprogress-spinner {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg); }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg); } }
`],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NgProgressBarComponent.ctorParameters = () => [
    { type: NgProgress, },
];
NgProgressBarComponent.propDecorators = {
    "ease": [{ type: Input },],
    "speed": [{ type: Input },],
    "meteor": [{ type: Input },],
    "spinner": [{ type: Input },],
    "spinnerPosition": [{ type: Input },],
    "direction": [{ type: Input },],
    "thick": [{ type: Input },],
    "color": [{ type: Input },],
};
const ɵ0 = n => -1 + n;
const ɵ1 = thick => `rotate(${thick ? 4 : 3}deg)`;
const ɵ2 = n => -n;
const ɵ3 = thick => `rotate(${thick ? 4 : 3}deg)`;
const ɵ4 = n => 1 - n;
const ɵ5 = thick => `rotate(${thick ? -4 : -3}deg)`;
const ɵ6 = (n) => n;
const ɵ7 = thick => `rotate(${thick ? -4 : -3}deg)`;
const directionSwitcher = {
    leftToRightIncreased: {
        bar: -100,
        toPercentage: ɵ0,
        spinnerClass: 'clockwise',
        meteorRotate: ɵ1,
        meteorLeft: 'unset'
    },
    leftToRightReduced: {
        bar: 0,
        toPercentage: ɵ2,
        spinnerClass: 'anti-clockwise',
        meteorRotate: ɵ3,
        meteorLeft: 'unset'
    },
    rightToLeftIncreased: {
        bar: 100,
        toPercentage: ɵ4,
        spinnerClass: 'anti-clockwise',
        meteorRotate: ɵ5,
        meteorLeft: 0
    },
    rightToLeftReduced: {
        bar: 0,
        toPercentage: ɵ6,
        spinnerClass: 'clockwise',
        meteorRotate: ɵ7,
        meteorLeft: 0
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgProgressComponent {
    /**
     * @param {?} progress
     */
    constructor(progress) {
        this.progress = progress;
        /**
         * Progress options
         */
        this.ease = 'linear';
        this.meteor = true;
        this.spinner = true;
        this.spinnerPosition = 'right';
        this.direction = 'leftToRightIncreased';
        this.color = '#1B95E0';
        this.thick = false;
        this.maximum = 1;
        this.minimum = 0.08;
        this.speed = 200;
        this.trickleSpeed = 300;
    }
    /**
     * Start/Stop Progressbar
     * @param {?} toggle
     * @return {?}
     */
    set toggleProgressbar(toggle) {
        toggle ? this.progress.start() : this.progress.done();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ minChng = changes["minimum"];
        const /** @type {?} */ maxChng = changes["maximum"];
        const /** @type {?} */ spdChng = changes["speed"];
        const /** @type {?} */ tklSpdChng = changes["trickleSpeed"];
        if (minChng) {
            if (typeof minChng.currentValue !== 'undefined' && minChng.currentValue !== minChng.previousValue) {
                if (minChng.currentValue < 0 || minChng.currentValue > 1) {
                    throw new Error('Input [minimum] must be between 0 and 1');
                }
                else {
                    this.progress.minimum = minChng.currentValue;
                }
            }
        }
        if (maxChng) {
            if (typeof maxChng.currentValue !== 'undefined' && maxChng.currentValue !== maxChng.previousValue) {
                if (maxChng.currentValue < 0 || maxChng.currentValue > 1) {
                    throw new Error('Input [maximum] must be between 0 and 1');
                }
                else {
                    this.progress.maximum = maxChng.currentValue;
                }
            }
        }
        if (spdChng) {
            if (typeof spdChng.currentValue !== 'undefined' && spdChng.currentValue !== spdChng.previousValue) {
                this.progress.speed = spdChng.currentValue;
            }
        }
        if (tklSpdChng) {
            if (typeof tklSpdChng.currentValue !== 'undefined' && tklSpdChng.currentValue !== tklSpdChng.previousValue) {
                this.progress.trickleSpeed = tklSpdChng.currentValue;
            }
        }
    }
}
NgProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress',
                template: `<ng-progress-bar
    [speed]="speed"
    [ease]="ease"
    [meteor]="meteor"
    [spinner]="spinner"
    [spinnerPosition]="spinnerPosition"
    [direction]="direction"
    [color]="color"
    [thick]="thick"
></ng-progress-bar>`,
                styles: [`:host {
  z-index: 999999;
  pointer-events: none;
  position: relative; }
`],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NgProgressComponent.ctorParameters = () => [
    { type: NgProgress, },
];
NgProgressComponent.propDecorators = {
    "ease": [{ type: Input },],
    "meteor": [{ type: Input },],
    "spinner": [{ type: Input },],
    "spinnerPosition": [{ type: Input },],
    "direction": [{ type: Input },],
    "color": [{ type: Input },],
    "thick": [{ type: Input },],
    "maximum": [{ type: Input },],
    "minimum": [{ type: Input },],
    "speed": [{ type: Input },],
    "trickleSpeed": [{ type: Input },],
    "toggleProgressbar": [{ type: Input, args: ['toggle',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgProgressModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgProgressModule,
            providers: [NgProgress]
        };
    }
}
NgProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NgProgressComponent,
                    NgProgressBarComponent
                ],
                exports: [NgProgressComponent],
                imports: [CommonModule]
            },] },
];
/** @nocollapse */
NgProgressModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgProgressModule, NgProgress, NgProgressBarComponent as ɵb, NgProgressComponent as ɵa };
//# sourceMappingURL=ngx-progressbar-core.js.map
